
\documentclass[submit]{ipsj}
%\documentclass{ipsj}

\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{cite}


\setcounter{巻数}{59}
\setcounter{号数}{1}
\setcounter{page}{1}


\受付{xxxx}{0}{0}
\採録{xxxx}{0}{0}

% newblockが未定義でbibtexが機能しない
\makeatletter
\newcommand\newblock{\hskip .11em\@plus.33em\@minus.07em}
\makeatother


\begin{document}


\title{論文タイトル}

\author{吉田 昂太}{Kota Yoshida}{IPSJ}

% \begin{abstract}
% \end{abstract}

% \begin{jkeyword}
% サイドチャネル攻撃, 投機的実行, ファジング
% \end{jkeyword}

\maketitle

%1
\section{概要}
現在の多くのプロセッサは投機的実行を悪用するSpectre攻撃に対して脆弱である。これらの攻撃に対処するソフトウェアベースの方法として、プログラム中からSpectre攻撃に対して脆弱なコード辺(Spectreガジェット)を特定し、部分的に投機的実行を抑制する方法がある。既存研究ではSpectreガジェットを検出する方法として記号実行を用いる手法が提案されているが、通常の実行パスと投機的実行パスの両方を探索する必要があるため、探索する状態空間が非常に多くなり複雑なプログラムに対してスケールしない問題がある。本論文では、Spectreガジェットの検出確率が低い投機的な状態の探索を避けることで、記号実行のスケーラビリティを向上させる手法を提案する。また、記号実行において探索されなかった投機的状態はファジングを用いて探索することで、スケーラビリティと精度の両立を目指す。

%2
\section{はじめに}

%3
\section{背景}
\subsection{投機実行}
現代のほぼ全ての CPU は1つの命令を、命令フェッチ、デコード、実行などの複数のステージに分割して実行するパイプライン方式を採用している。このようにすることで、前の命令が全ての処理を終えることを待たずに、次の命令の処理を開始できる。このように複数の命令を並行して処理することで CPU はスループットを向上させている。しかし、次に実行すべき命令が前の命令の実行結果に依存している場合、CPU は次にどの命令を実行するべきかわからないため命令の処理を停止させる必要がある。このような状況を制御ハザードと呼び、CPU のパフォーマンスが大幅に低下する可能性がある。このような制御ハザードによるストールを回避するため、現代の CPU は分岐命令に遭遇した場合、分岐予測器によって分岐先を予測し、後続の命令を投機的に実行する。{\color{red}(TODO: 分岐予測器の図と説明)}。投機的に実行された命令と実行結果は CPU 内部の Reorder Buffer (ROB) という機構で管理され、依存先の命令の完了を待機する。そのため、投機的に実行できる命令数は ROB の大きさに制限されており、マイクロオペレーション ($\mu$OP) で200命令程度である{\color{red}(TODO: ソースは？)}。分岐先が確定し予測が正しかった場合は、投機的実行の結果をレジスタやメモリなどのハードウェア状態に反映させる。分岐先が誤っていた場合は ROB から投機的実行の結果を破棄し、誤った予測が行われた時点のアーキテクチャ状態までロールバックされる。

\subsection{Side and Covert Channels}
コンピュータのシステムにおいて、channel とは情報を送信する可能性のある媒体のことを言う。channel には大きく分けてlegitimate channel と incidental channel の２種類が存在する。legitimate channel は システムの設計者が情報送信用に意図したチャネルであり、イーサネット、共有メモリ、IPC ソケットなどがある。逆にincidental channel は 偶発的に設計されたチャネルであり、リソースの競合、CPU キャッシュの状態、電力消費の変化などがある。更に、セキュリティ脅威モデルのコンテキストにおいて incidental channel は covert channel と side channel の２種類に分類される。covert channel は悪意のある送信者と受信者が意図的に情報の伝達を行うために利用される channel である。一方でside channel は、送信者は受信者に情報を伝達することを意図しておらず、情報が悪意のある受信者に伝達(つまり漏洩)される際に利用される channel である。つまり side channel を考慮する場合、情報を送信する被害者と情報を受け取る攻撃者が存在する。 incidental channel は 情報を伝達する方法に基づいて、タイミングベース、アクセスベース、またはトレースベースの channel に分類できる。タイミングベースの channel は、さまざまな操作のタイミングを利用して情報を漏洩します (例: [6、11、40])。たとえば、1 つのプロセスが多数のメモリ アクセスを実行すると、別のプロセスのメモリ アクセスが遅くなります。 

\subsection{一時実行攻撃}
一時実行攻撃とは、CPUの投機的実行によって一時的に実行される命令の結果をマイクロアーキテクチャに痕跡を残すことを利用する攻撃法である。本来、CPUは誤った投機的実行が行われた場合、その結果はマイクロアーキテクチャの状態には反映されず、パイプラインはフラッシュされる。しかし、キャッシュなどの一部のマイクロアーキテクチャの状態はパフォーマンスの観点からそのまま維持される。これを利用して、攻撃者は投機的実行を誘発させ、マイクロアーキテクチャの状態を通じて、後から秘密情報などを復元することが可能である。一時実行攻撃は2018年に Spectre攻撃\cite{8835233}と Meltdown攻撃\cite{217478}が初めて明らかにされて以来、様々なCPUを標的とした、多数の新しい一時実行攻撃が発見されてきた。これらの攻撃は大きく分けてSpectre型とMeltdown型に分類される\cite{canella2019systematic}。Spectre型の攻撃\cite{8835233,220586,10.1145/3243734.3243761,horn2018speculative}はデータフローまたは制御フローの予測ミスに続く一時的な命令を悪用する。一方で, Meltdown型の攻撃\cite{217478,van2018foreshadow, stecklina2018lazyfp,van2019ridl,van2020lvi}は fault を発生させる命令に続く一時的な命令を悪用する。一時実行攻撃は大きく分けて３つのフェーズで構成される。{\color{red}(TODO: 概要図)}。
まず攻撃者は分岐予測器やデータキャッシュの状態を設定し、マイクロアーキテクチャを目的の状態にする。次に、投機実行を引き起こす命令を実行する。これは、例外や分岐予測ミスなどにより、後続の命令が最終的に潰されるような命令である。CPUはトリガー命令が完了する前に後続の命令を一時的に実行する。この一時実行命令はマイクロアーキテクチャの秘密チャネルの送信側として機能し、秘密に依存するメモリ位置を CPU キャッシュにロードしたりする。トリガー命令の処理を終了すると、CPU は例外または分岐予測ミスを検出し、パイプラインをフラッシュし、アーキテクチャの状態をロールバックする。最後に攻撃者は、秘密チャネルの受信側で、メモリアクセスのタイミングを計って、秘密情報を一時実行命令から推測するなどして、許可されていない一時実行命令の結果を復元する。

\subsection{Spectre attack}
本研究の対象となるSpectre-V1の解説

\subsection{記号実行}

\subsection{ファジング}
ファジングは、ソフトウェアの欠陥や脆弱性を検出することを目的としたテスト手法である。ファジングは多数のテストケースを対象ソフトウェアへの入力として生成し、その実行結果を観測することでバグや脆弱性を検出する。単純にランダムにテストケースを生成すると入力空間が膨大になり非効率的であるため、多くのファジングツールは冗長なテストケースやバグを起こす可能性の低いテストケースの生成を回避する手法を用いている。
\section{KLEESpectre}


%4
\section{問題設定}
モチベ例について説明 \\
SpecFuzzの結果を引用 \\

%5
\section{提案手法}

%6
\section{実装}

%7
\section{評価}

%8
\section{関連研究}

%9
\section{結論}

\bibliographystyle{junsrt}
\bibliography{references}



\end{document}
