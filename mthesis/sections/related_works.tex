\section{関連研究}
\subsection{Transient Execution Attack}
transient execution attackは、大きく分けてSpectre型の攻撃とMeltdown型の攻撃に分類される。Spectre型の攻撃はSpectre-PHT\cite{8835233}、Spectre-BTB\cite{8835233}、Spectre-RSB\cite{220586,10.1145/3243734.3243761}、Spectre-STL\cite{Spectre-v4}の4つに分類され、いずれもキャッシュをサイドチャネルとして利用することに重点を置いている。Spectre-PHT攻撃はCPUのPattern History Table (PHT)を操作することで誤った投機実行を誘発させる。Spectre-BTB攻撃は間接ジャンプの飛び先を予測するための機構であるBranch Target Buffer (BTB)を操作することで、制御フローを操作して攻撃を行う。Spectre-RSB攻撃はリターンアドレスを予測するための機構であるReturn Stack Buffer (RSB)を操作することで、制御フローを操作して攻撃を行う。Spectre-STL攻撃は先行するストア命令が全て完了する前にロード命令される値を予測して利用するStore-To-Load forwarding (STL)による投機実行を悪用する攻撃である。\par

Meltdown型の攻撃は、CPUのアウト・オブ・オーダー実行によって、例外発生後に一時的に実行される命令を悪用する攻撃である。例えば、ユーザー空間からカーネルメモリの読み取り\cite{van2018foreshadow,217478,weisse2018foreshadow}や無効なレジスタや特権レジスタの読み取り\cite{intel-meltdown,stecklina2018lazyfp}などによって発生する例外を悪用することで攻撃を行う。\par
Meltdown型の攻撃に対しては、ハードウェアレベルの対策\cite{intel-meltdown-defence}やカーネルによる対策\cite{KAISER}など効率的な防御策が提供されている。一方、Spectre型の攻撃に対しては、ハードウェアレベルでの対策は未だ提供されておらず、ソフトウェアレベルでパフォーマンスを低下させず完全に防御することは困難である。本研究はSpectre-PHT攻撃に悪用されるSpectre Gadgetの検出のみに焦点を当てている。\par

\subsection{Spectre Gadgetの検出}
Spectre攻撃に対する最も保守的な防御法は全ての投機実行を無効にすることである。例えば、Spectre-PHT攻撃への対策として、全ての分岐命令やメモリアクセス命令に対して直列化命令やSLH\cite{LLVM-SLH}を適用することができる。しかし、既存研究\cite{wang2018oo7,oleksenko2020specfuzz}が示すように、この方法は非常に大きな実行時オーバヘッドを伴う。そこで、プログラム中のSpectre脆弱性を検出することで、全ての命令に対して防御を適用することを避けるために、Spectre Gadget検出ツールが利用される。\par

Spectre Gadgetの検出手法は、静的解析手法と動的解析手法に分類できる。静的解析手法では、Spectre 1 Scanner\cite{Spectre-Scanner}のように構文パターンを用いてSpectre Gadgetをモデル化し、バイナリに対して静的なパターンマッチングを行う方法がある。この手法は、定義済みのパターンにのみマッチするGadgetを検出するため、見逃しが発生する可能性があり、また単純なパターンマッチングに基づいているため、多くの誤検出が生じる。一方、oo7\cite{wang2018oo7}では、静的テイント解析を利用し、Spectre Gadget特有のデータフローを捉えることで検出を行う。この方法は構文パターンに基づく手法よりも正確にSpectre Gadgetをモデル化しているが、静的解析に特有の保守的な解析によって過剰汚染が発生し、多数の誤検出を引き起こす。
SPECTECTOR\cite{guarnieri2020spectector}とKLEESpectre\cite{wang2020kleespectre}は記号実行を使用してSpectre Gadgetを検出する。これは他のパス非依存な静的解析手法よりも正確であり、動的解析手法と比較してプログラムを網羅的に解析することができる。しかし、記号実行に固有の問題である状態数の爆発により、大規模な検体に対してはスケールしないという問題がある。この問題は特に、投機的なパスを考慮する必要があるSpectre Gadgetの検出において顕著である。それを踏まえて、本研究では、記号実行においてネストされた分岐予測ミスのシミュレーションに制限をかけることで、状態数の爆発を軽減し、スケーラビリティを向上させる手法を提案した。\par

動的解析手法としては、ファジングやテイント解析を活用した検出手法が提案されている。その中でもSpecFuzz\cite{oleksenko2020specfuzz}は、対象プログラムに計装を施し、投機実行をシミュレートすることで、ファジングを用いてシミュレーション中に発生した境界外アクセスを検出する。SpecFuzzは、ネストされた分岐予測ミスによって悪用可能なGadgetが少ないという観測に基づき、提案手法の記号実行フェーズと同様に、ネストされた分岐予測ミスのシミュレーションを抑制することでファジングのスループットを向上させている。しかし、このアプローチにより、複数回の分岐予測ミスを必要とするGadgetは見逃される可能性が高い。ファジングを利用した手法は記号実行に比べて大規模なプログラムにもスケールしやすいという利点があるが、カバレッジが不足すると脆弱性を見逃す可能性がある。また、SpecFuzzは単純な検出ロジックおよびシミュレーションロジックを採用しているため、誤検出が多発する可能性がある。

SpecTaint\cite{qi2021spectaint}は動的テイント解析を利用した手法で、攻撃者が操作可能な値を汚染することで、実際に悪用可能なGadgetのみを検出する。また、SpecTaintは例外を考慮した投機実行のシミュレーションを行うことで、より実際のCPUに近い動作を再現し、精度の高い解析を実現している。しかし、SpecFuzzと比較してシミュレーションロジックの複雑化によりファジングのスループットは低下している。
KASPER\cite{johannesmeyer2022kasper}はLinuxカーネルを対象としたファジングによるGadget検出ツールであり、transient execution attackで使用される手順をモデル化することで既存のツールより幅広い脆弱性を検出する手法を提案した。KASPERは本研究の記号実行フェーズと同様に、カーネルのような大規模な検体に対してのスケーラビリティを向上させるために、ネストされた分岐予測ミスのシミュレーションを制限している。その結果、ネストされた分岐予測ミスにより悪用可能なGadgetは見逃されることになる。提案手法はファザーをネストされた分岐予測ミスにより到達する投機的な状態を探索するように誘導することで、そのようなGadgetの検出を行う。\par

これらの動的解析手法に共通することは、ファジング固有の問題であるカバレッジ不足により脆弱性が見逃される可能性がある点である。本研究では、ファジングを記号実行と組み合わせることで、スケーラビリティを維持しつつ、より高い精度でSpectre Gadgetを検出する手法を提案した。\par

\subsection{ハードウェアによる防御法}
Spectre攻撃に対する根本的な防御策として、ハードウェアに変更を加えるアプローチが挙げられる。InvisiSpec\cite{yan2018invisispec}は、安全でない投機実行中のロード命令がキャッシュではなく、専用のハードウェア機構である投機バッファにデータをロードする手法を提案している。投機実行が正しかった場合には、投機バッファの内容がキャッシュに反映され、誤りだった場合にはその内容が破棄される。この手法により、投機実行中のロード命令がキャッシュの状態に影響を与えなくなるため、キャッシュをサイドチャネルとして悪用することができなくなる。しかし、このアプローチには、予測が正しかった場合でも投機バッファへのロードとキャッシュへの反映という二重のコストが伴うという課題がある。

CleanupSpec\cite{saileshwar2019cleanupspec}は、予測ミスが検出された際に、一時的な命令によってキャッシュに加えられた不正な変更をロールバックする手法を提案している。このアプローチはInvisiSpecとは異なり、正しい予測が行われた場合のロード命令は通常通りキャッシュにアクセスするだけで済むため、比較的オーバーヘッドは小さい。ただし、予測ミスが頻発する場合はキャッシュ状態のロールバックにかかるオーバーヘッドが非常に大きくなると考えられる。

NDA\cite{weisse2019nda}は、ハードウェアレベルで投機実行中のデータ伝播を制限する手法を提案している。この手法では、ソース命令が安全であると判断されるまで、その命令の結果を依存先に伝播させることを遅延させることで、誤った投機実行によるデータ漏洩を防ぐ。
ConTExT\cite{schwarz2020context}は、CPUのページテーブルエントリビットを拡張し、一時実行中のアクセスを制限する秘密情報が含まれていることを示す手法を提案している。この拡張により、CPUが投機実行中にこれらの秘密情報にアクセスしようとした場合、実際のデータの代わりにダミー値を使用することで、秘密情報がマイクロアーキテクチャの状態に漏洩することを防ぐ。ただし、この手法を利用するには、ユーザがソースコードレベルで秘密情報にアノテーションを付与することと、秘密情報を追跡するための動的テイント解析を実行することが必要である。\par

ハードウェアレベルの防御手法は、Spectre攻撃の原因に直接対処することで、ソフトウェアレベルの防御手法に比べてパフォーマンスの低下を最小限に抑えることができると考えられる。しかし、ハードウェア設計が複雑化することや、既に市場に出回っているCPUにこれらの防御手法を適用できないといった問題も存在する。\par

\subsection{その他の防御法}
ここでは、前述の手法以外のSpectre攻撃に対する防御手法について述べる。Site Isolation\cite{reis2019site}は、ブラウザにおける防御策であり、各ウェブサイトをそれぞれサンドボックス化されたプロセスに分離することで、信頼できないJavaScriptコードが同一プロセス内で実行されるのを防ぐ。これにより、攻撃者と被害者が同じメモリ空間を共有しないため、transient execution attackの難易度が向上する。しかし、この手法ではプロセス数が大幅に増加するため、メモリオーバーヘッドを低減するための最適化が必要となる。

SpecCFI\cite{9152786}は、制御フローハイジャック攻撃を防御するための手法であるControl-Flow Integrity (CFI)を活用し、Spectre攻撃（Spectre-BTBおよびSpectre-RSB）を防ぐ手法を提案している。この手法では、CFIを利用して間接分岐の可能なターゲットを制御フローグラフによって事前に定義された正当なターゲットに制限し、投機実行による不正な制御フローを抑制する。CFIはすでに一般的なハードウェアで利用可能であるため(IntelのCETやARMのBTIなど)、これらを活用することで、ハードウェア拡張を最小限に抑えつつ、小さいオーバーヘッドでSpectre攻撃を防御をする手法を提案している。

Swivel\cite{narayan2021swivel}は、WebAssembly（Wasm）のサンドボックス環境をSpectre攻撃に対して強化する手法を提案している。Wasmコンパイラは、プログラムをコンパイルする際に、制御フローをサンドボックス内に制限し、全てのメモリアクセスをサンドボックス内に収めるようマスク処理を施す。これにより、外部のサンドボックスへのアクセスを防止する。しかし、投機実行中にこれらのWasmの分離保証がバイパスされる可能性が依然として存在するため、Spectre攻撃が可能である。この問題に対処するため、Swivelはプログラムをリニアブロックと呼ばれる、終端以外に制御フロー命令を含まない直線的なコードブロックに分割する。さらに、コンパイル時に、逐次的または投機的な実行に関係なく、リニアブロックの先頭にのみジャンプするように制約を設ける。この手法により、投機実行中にメモリアクセスのマスク処理がバイパスされることを防ぐ。


