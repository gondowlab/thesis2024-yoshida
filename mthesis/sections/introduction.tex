\section{はじめに}

Spectre攻撃\cite{8835233,Spectre-v4,220586,10.1145/3243734.3243761}は、CPUの脆弱な投機実行を悪用して、被害者プロセスの秘密情報を漏洩させる攻撃手法である。投機実行とは、先行する命令の結果を待たずに、将来必要になる可能性が高い処理を事前に実行する最適化手法であり、CPUの性能向上に大きく貢献している。しかし、この最適化手法はほぼ全ての最新のCPUに実装されているため、Spectre攻撃はIntel、AMD、ARMなど、多くのCPUが標的となり、セキュリティ上の重大な懸念を引き起こしている。

Spectre-PHT\cite{8835233}はSpectre攻撃の一種であり、CPUの分岐予測による投機実行を悪用し、被害者のメモリ空間から秘密情報を盗み出す。たとえば、配列アクセスがインデックスの境界チェックによって保護されている場合でも、CPUの分岐予測器が分岐条件が満たされるとを誤って予測すると、分岐条件の評価が完了する前に配列アクセスを行う可能性がある。これにより、配列の境界外アクセスが発生し、秘密情報が読み取られる可能性がある。分岐予測が誤っていた場合、CPUはレジスタなどのアーキテクチャ状態をロールバックするが、キャッシュなどのマイクロアーキテクチャ状態はパフォーマンス上の理由からロールバックされない。Spectre攻撃はこの特性を利用し、投機実行中に読み取った秘密情報をキャッシュ状態に反映させることで、後から秘密情報を復元する。

Spectre脆弱性の多くは、Intelなどのハードウェアベンダーによる修正が期待できない\cite{intel-security}。そのため、Spectre攻撃に対する防御は、プログラム開発者がソフトウェアレベルで実施する必要がある。代表的な防御手法としては、直列化命令の挿入\cite{oleksenko2020specfuzz}とSpeculative Load Hardening (SLH)\cite{LLVM-SLH}が挙げられる。
元のプログラムの全ての条件分岐命令に対して直列化命令を挿入することで、分岐予測による投機実行を抑制し、Spectre攻撃を防ぐことができる。しかし、直列化命令以降の全てのメモリアクセス命令の投機実行が抑制されるため、Spectre攻撃に関与しない安全なメモリアクセス命令の投機実行も抑制されてしまい、大きなオーバーヘッドが発生する。一方で、SLHは、分岐条件と投機実行による漏洩のリスクがある危険なメモリアクセス命令との間に新たなデータ依存関係を追加することで、誤った投機実行時の危険なメモリアクセス命令の実行を抑制する手法である。SLHは、直列化命令を挿入する方法と異なり、特定の危険なメモリアクセス命令にのみ作用するため、投機実行の抑制範囲を限定できる。その結果、パフォーマンスへの影響を最小限に抑えながら、Spectre攻撃を防御することができる。

最も安全な防御手法は、全ての条件分岐命令に対してこれらの手法を適用し投機実行を抑制することである。しかし、既存研究\cite{wang2018oo7, oleksenko2020specfuzz, LLVM-SLH}では、このような保守的なアプローチを採用する場合、プログラムのパフォーマンスが大幅に低下することが報告されている。そこで、プログラム中からSpectre攻撃に脆弱なコード辺(Spectre Gadget)を検出し、これらのGadgetのみに防御手法を適用することで、オーバーヘッドを軽減する方法が提案されている。

Spectre Gadgetの検出手法は、大きく静的解析手法\cite{Spectre-Scanner,wang2018oo7,guarnieri2020spectector,wang2020kleespectre}と動的解析手法\cite{oleksenko2020specfuzz,qi2021spectaint,johannesmeyer2022kasper}に分類される。静的解析手法の一例として、記号実行を用いる手法\cite{guarnieri2020spectector,wang2020kleespectre}が提案されている。この手法では、記号実行において通常の実行パスに加え、分岐予測による投機的なパスも考慮して探索を行うことでGadgetを検出する。記号実行を用いることで、他のパス非依存な静的解析手法と比較してGadgetの検出がより正確であり、動的解析手法よりも網羅的にプログラムを解析することが可能である。しかし、記号実行固有の問題として、状態数の爆発により、大規模なプログラムに対してはスケールしないという問題がある。
一方、動的解析手法ではファジングを用いる手法\cite{oleksenko2020specfuzz,qi2021spectaint,johannesmeyer2022kasper}が提案されている。この手法では、対象プログラムに計装を施すことで、ソフトウェアレベルで投機実行をシミュレートし、ファジングを用いて投機実行中に発生した境界外アクセスを検出する。ファジングを利用した手法は、記号実行と比較して大規模なプログラムに対してもスケールするという利点がある。しかし、ファジング固有の問題として、カバレッジ不足によりGadgetが見逃される可能性がある。

そこで本研究では、スケーラビリティと精度を両立させる新しいSpectre Gadgetの検出手法を提案する。提案手法は、記号実行フェーズとファジングフェーズの2つのフェーズで構成され、それぞれ異なる解析手法を用いることでGadgetを効率的に検出することを試みる。記号実行フェーズでは記号実行を用いてGadgetを検出するが、既存手法\cite{guarnieri2020spectector,wang2020kleespectre}とは異なり、ネストされた分岐予測ミスの回数に制限を設けている。CPUはネストされた分岐予測ミスによる投機実行が可能であり\cite{mambretti2019speculator}、従来の記号実行手法ではこのような状態を網羅的に探索するため、分岐予測ミスのシミュレーションを深くネストして行う場合がある。しかし、先行研究\cite{oleksenko2020specfuzz}によると、ネストされた分岐予測ミスによって悪用可能なGadgetの数は非常に限られていることが示されている。そこで本研究では、記号実行フェーズにおいてネストされた分岐予測ミスの回数を制限し、投機的状態の探索範囲を縮小し、記号実行のスケーラビリティを向上させる。
ファジングフェーズでは、ファジングを用いて記号実行フェーズで探索されなかった投機的な状態(ターゲット状態)を集中的にテストし、見逃された一部のGadgetを効率的に検出することを試みる。この際、記号実行フェーズで得られた解析結果を用いて、不要な投機的な状態の探索をなるべく回避することで、ファジングのスループットを向上させる。また、解析結果を元に、テストケースのターゲット状態への到達可能性を評価するための計装を行う。この評価結果を活用してシードのスケジューリングを最適化し、ターゲット状態に到達する可能性の高いシードを優先的に実行させる。\par
提案手法の有効性を評価するため、提案手法のプロトタイプを実装し評価を行った。評価には、一般的に広く利用されている暗号化ライブラリであるOpenSSL\cite{OpenSSL}からいくつかのプログラムを選択しデータセットを作成した。予備実験の結果、いくつかの検体において記号実行のスケーラビリティが大幅に向上することを確認した。解析全体としては、既存手法よりも効率的にSpectre Gadgetを検出した検体を確認した。\par

本研究の主な貢献は以下の通りである：

\begin{itemize} 
  \item 記号実行とファジングを組み合わせた新しいSpectre Gadgetの検出手法を提案した。 
  \item 記号実行の解析結果を活用し、ファジングで効率的に状態を探索する手法を提案した。 
  \item 予備実験を通じて、ネストされた分岐予測ミスを抑制することで記号実行のスケーラビリティが向上することを確認した。 
  \item 予備実験を通じて、既存手法と比較して、提案手法が特定の検体においてより効率的にSpectre Gadgetを検出できることを確認した。 
\end{itemize}
